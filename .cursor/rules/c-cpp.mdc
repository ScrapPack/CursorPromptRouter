# C/C++ Development Rules

You are an expert in C and C++ programming, systems programming, and memory management.

## Core Principles

- Write efficient, portable C/C++ code
- Manage memory carefully to avoid leaks and corruption
- Use appropriate language features for C vs C++
- Follow established coding standards and conventions
- Prioritize performance and system-level programming

## Memory Management

### C Memory Management
```c
#include <stdlib.h>
#include <string.h>

// Good: Proper allocation and deallocation
char* create_string(const char* source) {
    if (!source) return NULL;
    
    size_t len = strlen(source);
    char* result = malloc(len + 1);
    if (!result) return NULL;
    
    strcpy(result, source);
    return result;
}

void destroy_string(char* str) {
    if (str) {
        free(str);
    }
}

// Good: RAII-style in C++
class String {
private:
    char* data;
    size_t length;
    
public:
    String(const char* str = "") : data(nullptr), length(0) {
        if (str) {
            length = strlen(str);
            data = new char[length + 1];
            strcpy(data, str);
        }
    }
    
    ~String() {
        delete[] data;
    }
    
    // Copy constructor
    String(const String& other) : data(nullptr), length(other.length) {
        if (other.data) {
            data = new char[length + 1];
            strcpy(data, other.data);
        }
    }
    
    // Assignment operator
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data;
            length = other.length;
            if (other.data) {
                data = new char[length + 1];
                strcpy(data, other.data);
            } else {
                data = nullptr;
            }
        }
        return *this;
    }
};
```

### Smart Pointers (C++)
```cpp
#include <memory>
#include <vector>

// Good: Use smart pointers for automatic memory management
class Resource {
public:
    Resource(int id) : id_(id) {
        std::cout << "Resource " << id_ << " created\n";
    }
    
    ~Resource() {
        std::cout << "Resource " << id_ << " destroyed\n";
    }
    
private:
    int id_;
};

// Unique ownership
std::unique_ptr<Resource> create_resource(int id) {
    return std::make_unique<Resource>(id);
}

// Shared ownership
std::shared_ptr<Resource> create_shared_resource(int id) {
    return std::make_shared<Resource>(id);
}

// Usage
void use_resources() {
    auto resource1 = create_resource(1);
    auto resource2 = create_shared_resource(2);
    
    std::vector<std::shared_ptr<Resource>> resources;
    resources.push_back(resource2);
    
    // Automatic cleanup when scope ends
}
```

## Error Handling

### C Error Handling
```c
#include <errno.h>
#include <stdio.h>

typedef enum {
    SUCCESS = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_INPUT,
    ERROR_MEMORY_ALLOCATION,
    ERROR_FILE_NOT_FOUND
} error_code_t;

// Good: Consistent error handling
error_code_t process_file(const char* filename, char** output) {
    if (!filename || !output) {
        return ERROR_NULL_POINTER;
    }
    
    FILE* file = fopen(filename, "r");
    if (!file) {
        return ERROR_FILE_NOT_FOUND;
    }
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    *output = malloc(size + 1);
    if (!*output) {
        fclose(file);
        return ERROR_MEMORY_ALLOCATION;
    }
    
    size_t read_size = fread(*output, 1, size, file);
    (*output)[read_size] = '\0';
    
    fclose(file);
    return SUCCESS;
}
```

### C++ Exception Handling
```cpp
#include <stdexcept>
#include <fstream>
#include <sstream>

class FileError : public std::runtime_error {
public:
    FileError(const std::string& message) : std::runtime_error(message) {}
};

// Good: RAII with exception safety
std::string read_file(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw FileError("Could not open file: " + filename);
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

// Exception-safe function
void process_files(const std::vector<std::string>& filenames) {
    std::vector<std::string> contents;
    contents.reserve(filenames.size());
    
    try {
        for (const auto& filename : filenames) {
            contents.push_back(read_file(filename));
        }
        
        // Process contents...
        
    } catch (const FileError& e) {
        std::cerr << "File error: " << e.what() << std::endl;
        // Cleanup is automatic due to RAII
    }
}
```

## Data Structures and Algorithms

### C Data Structures
```c
// Dynamic array implementation
typedef struct {
    void** data;
    size_t size;
    size_t capacity;
    size_t element_size;
} dynamic_array_t;

dynamic_array_t* array_create(size_t element_size, size_t initial_capacity) {
    dynamic_array_t* arr = malloc(sizeof(dynamic_array_t));
    if (!arr) return NULL;
    
    arr->data = malloc(element_size * initial_capacity);
    if (!arr->data) {
        free(arr);
        return NULL;
    }
    
    arr->size = 0;
    arr->capacity = initial_capacity;
    arr->element_size = element_size;
    return arr;
}

int array_push(dynamic_array_t* arr, const void* element) {
    if (!arr || !element) return -1;
    
    if (arr->size >= arr->capacity) {
        size_t new_capacity = arr->capacity * 2;
        void** new_data = realloc(arr->data, arr->element_size * new_capacity);
        if (!new_data) return -1;
        
        arr->data = new_data;
        arr->capacity = new_capacity;
    }
    
    memcpy((char*)arr->data + (arr->size * arr->element_size), element, arr->element_size);
    arr->size++;
    return 0;
}

void array_destroy(dynamic_array_t* arr) {
    if (arr) {
        free(arr->data);
        free(arr);
    }
}
```

### C++ STL Usage
```cpp
#include <vector>
#include <map>
#include <algorithm>
#include <iterator>

// Good: STL container usage
class DataProcessor {
private:
    std::vector<int> data_;
    std::map<std::string, int> counters_;
    
public:
    void add_data(int value) {
        data_.push_back(value);
    }
    
    void process_data() {
        // Sort data
        std::sort(data_.begin(), data_.end());
        
        // Remove duplicates
        auto it = std::unique(data_.begin(), data_.end());
        data_.erase(it, data_.end());
        
        // Transform data
        std::transform(data_.begin(), data_.end(), data_.begin(),
                      [](int x) { return x * 2; });
    }
    
    std::vector<int> filter_data(int threshold) const {
        std::vector<int> result;
        std::copy_if(data_.begin(), data_.end(), std::back_inserter(result),
                    [threshold](int x) { return x > threshold; });
        return result;
    }
    
    void increment_counter(const std::string& key) {
        counters_[key]++;
    }
};
```

## Performance Optimization

### Cache-Friendly Programming
```c
// Good: Structure of arrays for better cache locality
typedef struct {
    float* x_coords;
    float* y_coords;
    float* z_coords;
    size_t count;
    size_t capacity;
} point_array_t;

// Bad: Array of structures (poor cache locality for vector operations)
typedef struct {
    float x, y, z;
} point_t;

// Good: Vectorized operations
void translate_points_soa(point_array_t* points, float dx, float dy, float dz) {
    for (size_t i = 0; i < points->count; ++i) {
        points->x_coords[i] += dx;
        points->y_coords[i] += dy;
        points->z_coords[i] += dz;
    }
}
```

### Template Optimization (C++)
```cpp
// Good: Template specialization for performance
template<typename T>
class Vector {
private:
    T* data_;
    size_t size_;
    size_t capacity_;
    
public:
    void push_back(const T& value) {
        if (size_ >= capacity_) {
            resize();
        }
        data_[size_++] = value;
    }
    
private:
    void resize() {
        capacity_ = capacity_ ? capacity_ * 2 : 1;
        T* new_data = new T[capacity_];
        for (size_t i = 0; i < size_; ++i) {
            new_data[i] = std::move(data_[i]);
        }
        delete[] data_;
        data_ = new_data;
    }
};

// Specialization for bool (bit packing)
template<>
class Vector<bool> {
private:
    uint64_t* data_;
    size_t size_;
    size_t capacity_;
    
public:
    void push_back(bool value) {
        if (size_ >= capacity_ * 64) {
            resize();
        }
        
        size_t word_index = size_ / 64;
        size_t bit_index = size_ % 64;
        
        if (value) {
            data_[word_index] |= (1ULL << bit_index);
        } else {
            data_[word_index] &= ~(1ULL << bit_index);
        }
        
        ++size_;
    }
};
```

## Concurrency and Threading

### Pthread Usage (C)
```c
#include <pthread.h>
#include <semaphore.h>

typedef struct {
    int* data;
    size_t start;
    size_t end;
    int target;
    int result;
} search_args_t;

void* parallel_search(void* arg) {
    search_args_t* args = (search_args_t*)arg;
    
    for (size_t i = args->start; i < args->end; ++i) {
        if (args->data[i] == args->target) {
            args->result = i;
            return NULL;
        }
    }
    
    args->result = -1;
    return NULL;
}

int parallel_find(int* data, size_t size, int target, int num_threads) {
    pthread_t* threads = malloc(sizeof(pthread_t) * num_threads);
    search_args_t* args = malloc(sizeof(search_args_t) * num_threads);
    
    size_t chunk_size = size / num_threads;
    
    for (int i = 0; i < num_threads; ++i) {
        args[i].data = data;
        args[i].start = i * chunk_size;
        args[i].end = (i == num_threads - 1) ? size : (i + 1) * chunk_size;
        args[i].target = target;
        args[i].result = -1;
        
        pthread_create(&threads[i], NULL, parallel_search, &args[i]);
    }
    
    int result = -1;
    for (int i = 0; i < num_threads; ++i) {
        pthread_join(threads[i], NULL);
        if (args[i].result != -1) {
            result = args[i].result;
        }
    }
    
    free(threads);
    free(args);
    return result;
}
```

### C++ Threading
```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <future>

// Thread-safe queue
template<typename T>
class ThreadSafeQueue {
private:
    mutable std::mutex mutex_;
    std::queue<T> queue_;
    std::condition_variable condition_;
    
public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(item);
        condition_.notify_one();
    }
    
    bool try_pop(T& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return false;
        }
        item = queue_.front();
        queue_.pop();
        return true;
    }
    
    void wait_and_pop(T& item) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (queue_.empty()) {
            condition_.wait(lock);
        }
        item = queue_.front();
        queue_.pop();
    }
};

// Parallel algorithm example
template<typename Iterator, typename Func>
void parallel_for_each(Iterator first, Iterator last, Func f) {
    const size_t length = std::distance(first, last);
    if (length == 0) return;
    
    const size_t min_per_thread = 25;
    const size_t max_threads = (length + min_per_thread - 1) / min_per_thread;
    const size_t hardware_threads = std::thread::hardware_concurrency();
    const size_t num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);
    const size_t block_size = length / num_threads;
    
    std::vector<std::future<void>> futures(num_threads - 1);
    
    Iterator block_start = first;
    for (size_t i = 0; i < (num_threads - 1); ++i) {
        Iterator block_end = block_start;
        std::advance(block_end, block_size);
        
        futures[i] = std::async(std::launch::async, [=]() {
            std::for_each(block_start, block_end, f);
        });
        
        block_start = block_end;
    }
    
    std::for_each(block_start, last, f);
    
    for (auto& future : futures) {
        future.get();
    }
}
```

## Build Systems and Project Structure

### Makefile Example
```makefile
# Makefile for C project
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -O2
LDFLAGS = -lpthread
TARGET = myapp
SRCDIR = src
OBJDIR = obj
SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)

.PHONY: all clean debug release

all: $(TARGET)

$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $@ $(LDFLAGS)

$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@

debug: CFLAGS += -g -DDEBUG
debug: $(TARGET)

release: CFLAGS += -DNDEBUG
release: $(TARGET)

clean:
	rm -rf $(OBJDIR) $(TARGET)

install: $(TARGET)
	cp $(TARGET) /usr/local/bin/
```

### CMakeLists.txt Example
```cmake
cmake_minimum_required(VERSION 3.16)
project(MyProject VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Options
option(BUILD_TESTS "Build test programs" ON)
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)

# Find packages
find_package(Threads REQUIRED)
find_package(Boost REQUIRED COMPONENTS system filesystem)

# Include directories
include_directories(include)

# Source files
file(GLOB_RECURSE SOURCES "src/*.cpp")
file(GLOB_RECURSE HEADERS "include/*.hpp")

# Create library
add_library(${PROJECT_NAME} ${SOURCES} ${HEADERS})
target_link_libraries(${PROJECT_NAME} 
    Threads::Threads 
    Boost::system 
    Boost::filesystem
)

# Create executable
add_executable(${PROJECT_NAME}_app main.cpp)
target_link_libraries(${PROJECT_NAME}_app ${PROJECT_NAME})

# Tests
if(BUILD_TESTS)
    enable_testing()
    add_subdirectory(tests)
endif()

# Installation
install(TARGETS ${PROJECT_NAME} ${PROJECT_NAME}_app
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)
```

## Best Practices Summary

### Code Style
- Use consistent indentation (2 or 4 spaces)
- Follow naming conventions (snake_case for C, camelCase/PascalCase for C++)
- Keep functions small and focused
- Use meaningful variable and function names
- Document complex algorithms and data structures

### Memory Safety
- Always check return values from malloc/new
- Match every malloc with free, every new with delete
- Use RAII in C++ for automatic resource management
- Avoid raw pointers in modern C++, prefer smart pointers
- Initialize all variables before use

### Error Handling
- Use consistent error handling patterns
- Check for error conditions early
- Provide meaningful error messages
- Clean up resources on error paths
- Use exceptions appropriately in C++

### Performance
- Profile before optimizing
- Understand cache behavior and memory layout
- Use appropriate data structures for the problem
- Minimize memory allocations in hot paths
- Consider compiler optimizations and flags

Follow established C/C++ standards and leverage appropriate language features for systems programming.
