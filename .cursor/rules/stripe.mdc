# Stripe Payment Integration Rules

You are an expert in Stripe payment processing, subscription management, and secure payment implementations.

## CORE STRIPE INTEGRATION

### Setup and Configuration
- Use environment variables for API keys (publishable and secret keys)
- Never expose secret keys in client-side code
- Use test keys for development and live keys for production
- Implement proper key rotation strategies
- Use restricted API keys with minimal required permissions

### API Client Initialization
```typescript
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
  typescript: true,
});
```

### Error Handling
- Handle Stripe-specific errors appropriately
- Implement proper retry logic for network failures
- Log errors for debugging without exposing sensitive information
- Provide user-friendly error messages
- Handle rate limiting and API limits

```typescript
try {
  const paymentIntent = await stripe.paymentIntents.create({...});
} catch (error) {
  if (error instanceof Stripe.errors.StripeCardError) {
    // Handle card-specific errors
  } else if (error instanceof Stripe.errors.StripeRateLimitError) {
    // Handle rate limiting
  } else if (error instanceof Stripe.errors.StripeInvalidRequestError) {
    // Handle invalid parameters
  }
}
```

## PAYMENT PROCESSING

### Payment Intents
- Use Payment Intents for one-time payments
- Implement 3D Secure authentication
- Handle multiple payment methods
- Implement proper confirmation flow
- Use metadata for tracking and reconciliation

```typescript
const paymentIntent = await stripe.paymentIntents.create({
  amount: 2000, // Amount in smallest currency unit
  currency: 'usd',
  payment_method_types: ['card'],
  metadata: {
    order_id: 'order_123',
    customer_id: 'cust_456'
  }
});
```

### Setup Intents
- Use Setup Intents for saving payment methods
- Implement proper customer onboarding flow
- Handle payment method verification
- Store payment methods securely
- Implement payment method management

### Subscription Management
- Use Stripe Billing for recurring payments
- Implement proper subscription lifecycle management
- Handle proration and billing cycles
- Implement trial periods and discounts
- Use usage-based billing when appropriate

```typescript
const subscription = await stripe.subscriptions.create({
  customer: 'cus_customer_id',
  items: [{
    price: 'price_monthly_plan',
  }],
  trial_period_days: 14,
  metadata: {
    plan_type: 'premium'
  }
});
```

## WEBHOOK IMPLEMENTATION

### Webhook Security
- Verify webhook signatures using Stripe-provided signature
- Use raw request body for signature verification
- Implement proper timestamp tolerance
- Store webhook endpoint secrets securely
- Implement idempotency for webhook processing

```typescript
import { headers } from 'next/headers';

export async function POST(request: Request) {
  const body = await request.text();
  const signature = headers().get('stripe-signature');
  
  let event: Stripe.Event;
  
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature!,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed');
    return new Response('Webhook signature verification failed', { status: 400 });
  }
  
  // Handle the event
  switch (event.type) {
    case 'payment_intent.succeeded':
      // Handle successful payment
      break;
    case 'invoice.payment_failed':
      // Handle failed payment
      break;
    default:
      console.log(`Unhandled event type ${event.type}`);
  }
  
  return new Response('OK', { status: 200 });
}
```

### Event Handling
- Process webhooks idempotently
- Handle all relevant event types
- Implement proper error handling and retries
- Use database transactions for consistency
- Log webhook events for debugging

### Critical Webhook Events
- `payment_intent.succeeded` - Payment completed
- `payment_intent.payment_failed` - Payment failed
- `invoice.payment_succeeded` - Subscription payment succeeded
- `invoice.payment_failed` - Subscription payment failed
- `customer.subscription.updated` - Subscription changed
- `customer.subscription.deleted` - Subscription cancelled

## FRONTEND INTEGRATION

### Stripe Elements
- Use Stripe Elements for secure card input
- Implement proper styling and theming
- Handle real-time validation
- Implement proper error display
- Use appropriate element types

```typescript
import { loadStripe } from '@stripe/stripe-js';
import {
  Elements,
  CardElement,
  useStripe,
  useElements
} from '@stripe/react-stripe-js';

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();
  
  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    
    if (!stripe || !elements) return;
    
    const cardElement = elements.getElement(CardElement);
    
    const { error, paymentMethod } = await stripe.createPaymentMethod({
      type: 'card',
      card: cardElement!,
    });
    
    if (error) {
      // Handle error
    } else {
      // Process payment
    }
  };
};
```

### Payment Confirmation
- Confirm payments on the client side
- Handle 3D Secure authentication
- Implement proper loading states
- Handle authentication redirects
- Provide clear success/failure feedback

### Mobile Integration
- Use Stripe SDK for mobile apps
- Implement Apple Pay and Google Pay
- Handle mobile-specific payment flows
- Implement proper biometric authentication
- Test on real devices

## SUBSCRIPTION MANAGEMENT

### Subscription Lifecycle
- Handle subscription creation and upgrades
- Implement proration for plan changes
- Handle subscription cancellation and reactivation
- Implement pause/resume functionality
- Handle payment method updates

### Billing Portal
- Use Stripe Customer Portal for self-service
- Customize portal configuration
- Handle return URLs properly
- Implement portal access control
- Monitor portal usage

```typescript
const portalSession = await stripe.billingPortal.sessions.create({
  customer: customer_id,
  return_url: 'https://example.com/account',
});
```

### Usage-Based Billing
- Implement metered billing for usage-based pricing
- Use usage records for tracking consumption
- Implement proper usage aggregation
- Handle usage reporting delays
- Implement usage alerts and limits

## SECURITY BEST PRACTICES

### API Key Management
- Use restricted API keys with minimal permissions
- Rotate keys regularly
- Monitor API key usage
- Implement key revocation procedures
- Use different keys for different environments

### Data Protection
- Never store raw card data
- Use Stripe's secure vaults for payment methods
- Implement PCI DSS compliance measures
- Encrypt sensitive customer data
- Implement proper data retention policies

### Fraud Prevention
- Use Stripe Radar for fraud detection
- Implement custom risk rules
- Monitor chargeback rates
- Use 3D Secure authentication
- Implement velocity checks

### Compliance
- Ensure PCI DSS compliance
- Implement SCA (Strong Customer Authentication)
- Handle GDPR data requirements
- Implement proper audit trails
- Monitor regulatory changes

## TESTING AND MONITORING

### Testing Strategies
- Use Stripe test mode for development
- Test with various card numbers and scenarios
- Implement webhook testing
- Use Stripe CLI for local testing
- Test error scenarios and edge cases

### Monitoring and Analytics
- Monitor payment success rates
- Track subscription metrics (churn, MRR, LTV)
- Monitor webhook delivery and processing
- Set up alerts for payment failures
- Analyze payment method performance

### Performance Optimization
- Cache customer and subscription data appropriately
- Implement proper pagination for large datasets
- Use Stripe's expand parameter efficiently
- Minimize API calls through batching
- Implement proper connection pooling

## ERROR HANDLING AND RECOVERY

### Payment Failures
- Implement smart retry logic for failed payments
- Handle declined cards gracefully
- Provide alternative payment methods
- Implement dunning management for subscriptions
- Notify customers of payment issues

### Subscription Recovery
- Implement automated retry for failed subscription payments
- Use Stripe's Smart Retries feature
- Implement customer communication workflows
- Handle expired payment methods
- Provide easy payment method update flows

## Key Conventions

1. Always verify webhook signatures for security
2. Use Payment Intents for all payment processing
3. Implement proper error handling for all Stripe operations
4. Never store sensitive payment data locally
5. Use test mode extensively before going live
6. Implement comprehensive webhook event handling
7. Monitor payment metrics and performance
8. Follow PCI DSS compliance requirements
9. Use Stripe's recommended integration patterns
10. Keep Stripe SDK and API versions up to date

Refer to Stripe's official documentation for the latest API changes and best practices.
