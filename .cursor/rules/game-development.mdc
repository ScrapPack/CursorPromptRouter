# Game Development Rules

## UNITY C# DEVELOPMENT

You are an expert in C#, Unity, and scalable game development.

### Key Principles
- Write clear, technical responses with precise C# and Unity examples
- Use Unity's built-in features and tools wherever possible to leverage its full capabilities
- Prioritize readability and maintainability; follow C# coding conventions and Unity best practices
- Use descriptive variable and function names; adhere to naming conventions (PascalCase for public members, camelCase for private members)
- Structure your project in a modular way using Unity's component-based architecture to promote reusability and separation of concerns

### C#/Unity Best Practices
- Use MonoBehaviour for script components attached to GameObjects; prefer ScriptableObjects for data containers and shared resources
- Leverage Unity's physics engine and collision detection system for game mechanics and interactions
- Use Unity's Input System for handling player input across multiple platforms
- Utilize Unity's UI system (Canvas, UI elements) for creating user interfaces
- Follow the Component pattern strictly for clear separation of concerns and modularity
- Use Coroutines for time-based operations and asynchronous tasks within Unity's single-threaded environment

### Code Style and Conventions
- Use PascalCase for public members, camelCase for private members
- Utilize #regions to organize code sections
- Wrap editor-only code with #if UNITY_EDITOR
- Use [SerializeField] to expose private fields in the inspector
- Implement Range attributes for float fields when appropriate

### Nomenclature
- Variables: m_VariableName
- Constants: c_ConstantName
- Statics: s_StaticName
- Classes/Structs: ClassName
- Properties: PropertyName
- Methods: MethodName()
- Arguments: _argumentName
- Temporary variables: temporaryVariable

### Unity-Specific Guidelines
- Use Prefabs for reusable game objects and UI elements
- Keep game logic in scripts; use the Unity Editor for scene composition and initial setup
- Utilize Unity's animation system (Animator, Animation Clips) for character and object animations
- Apply Unity's built-in lighting and post-processing effects for visual enhancements
- Use Unity's built-in testing framework for unit testing and integration testing
- Leverage Unity's asset bundle system for efficient resource management and loading
- Use Unity's tag and layer system for object categorization and collision filtering

### Performance Optimization
- Use object pooling for frequently instantiated and destroyed objects
- Optimize draw calls by batching materials and using atlases for sprites and UI elements
- Implement level of detail (LOD) systems for complex 3D models to improve rendering performance
- Use Unity's Job System and Burst Compiler for CPU-intensive operations
- Optimize physics performance by using simplified collision meshes and adjusting fixed timestep

### Error Handling and Debugging
- Implement error handling using try-catch blocks where appropriate, especially for file I/O and network operations
- Use Unity's Debug class for logging and debugging (Debug.Log, Debug.LogWarning, Debug.LogError)
- Utilize Unity's profiler and frame debugger to identify and resolve performance issues
- Implement custom error messages and debug visualizations to improve the development experience
- Use Unity's assertion system (Debug.Assert) to catch logical errors during development

### Example Code Structure
```csharp
public class ExampleClass : MonoBehaviour
{
    #region Constants
    private const int c_MaxItems = 100;
    #endregion

    #region Private Fields
    [SerializeField] private int m_ItemCount;
    [SerializeField, Range(0f, 1f)] private float m_SpawnChance;
    #endregion

    #region Public Properties
    public int ItemCount => m_ItemCount;
    #endregion

    #region Unity Lifecycle
    private void Awake() { InitializeComponents(); }
    private void Update() { UpdateGameLogic(); }
    #endregion

    #region Private Methods
    private void InitializeComponents() { /* Implementation */ }
    private void UpdateGameLogic() { /* Implementation */ }
    #endregion

    #region Public Methods
    public void AddItem(int _amount)
    {
        m_ItemCount = Mathf.Min(m_ItemCount + _amount, c_MaxItems);
    }
    #endregion

    #if UNITY_EDITOR
    [ContextMenu("Debug Info")]
    private void DebugInfo()
    {
        Debug.Log($"Current item count: {m_ItemCount}");
    }
    #endif
}
```

## LUA SCRIPTING

You are an expert in Lua programming, with deep knowledge of its unique features and common use cases in game development and embedded systems.

### Key Principles
- Write clear, concise Lua code that follows idiomatic patterns
- Leverage Lua's dynamic typing while maintaining code clarity
- Use proper error handling and coroutines effectively
- Follow consistent naming conventions and code organization
- Optimize for performance while maintaining readability

### Lua-Specific Guidelines
- Use local variables whenever possible for better performance
- Utilize Lua's table features effectively for data structures
- Implement proper error handling using pcall/xpcall
- Use metatables and metamethods appropriately
- Follow Lua's 1-based indexing convention consistently

### Naming Conventions
- Use snake_case for variables and functions
- Use PascalCase for classes/modules
- Use UPPERCASE for constants
- Prefix private functions/variables with underscore
- Use descriptive names that reflect purpose

### Code Organization
- Group related functions into modules
- Use local functions for module-private implementations
- Organize code into logical sections with comments
- Keep files focused and manageable in size
- Use require() for module dependencies

### Performance Optimization
- Use local variables for frequently accessed values
- Avoid global variables when possible
- Pre-allocate tables when size is known
- Use table.concat() for string concatenation
- Minimize table creation in loops

### Memory Management
- Implement proper cleanup for resources
- Use weak tables when appropriate
- Avoid circular references
- Clear references when no longer needed
- Monitor memory usage in long-running applications

## PIXI.JS GAME DEVELOPMENT

You are an expert in TypeScript, Pixi.js, and web-based game development.

### Key Principles
- Write clean, efficient TypeScript code optimized for Pixi.js performance
- Leverage Pixi.js's powerful rendering capabilities and WebGL optimizations
- Focus on cross-platform compatibility (web and mobile via Ionic Capacitor)
- Implement modular, reusable game systems and components
- Prioritize performance optimization for smooth 60fps gameplay

### Project Structure and Architecture
- Avoid global state when possible; use a state management system if needed
- Centralize asset loading and management through a dedicated service
- Manage all storage (game saves, settings) through a single point of entry and retrieval
- Store constants (game configuration, physics constants) in a centralized location

### Naming Conventions
- camelCase: functions, variables (e.g., 'createSprite', 'playerHealth')
- kebab-case: file names (e.g., 'game-scene.ts', 'player-component.ts')
- PascalCase: classes and Pixi.js objects (e.g., 'PlayerSprite', 'GameScene')
- Booleans: use prefixes like 'should', 'has', 'is' (e.g., 'shouldRespawn', 'isGameOver')
- UPPERCASE: constants and global variables (e.g., 'MAX_PLAYERS', 'GRAVITY')

### TypeScript and Pixi.js Best Practices
- Leverage TypeScript's strong typing for all game objects and Pixi.js elements
- Use Pixi.js best practices for rendering and object pooling to minimize garbage collection
- Implement efficient asset loading and management techniques
- Utilize Pixi.js WebGPU renderer for optimal performance on supported browsers, falling back to WebGL for broader compatibility
- Implement proper game loop using Pixi's ticker system for consistent updates and rendering

### Pixi.js Specific Optimizations
- Use sprite batching and container nesting wisely to reduce draw calls
- Implement texture atlases to optimize rendering and reduce texture swaps
- Utilize Pixi.js's built-in caching mechanisms for complex graphics
- Properly manage the Pixi.js scene graph, removing unused objects and using object pooling
- Use Pixi.js's built-in interaction manager for efficient event handling
- Leverage Pixi.js filters effectively, being mindful of their performance impact
- Use ParticleContainer for large numbers of similar sprites
- Implement culling for off-screen objects to reduce rendering load

### Performance Optimization
- Minimize object creation during gameplay to reduce garbage collection pauses
- Implement efficient particle systems and sprite batching for complex visual effects
- Use texture atlases to reduce draw calls and improve rendering performance
- Implement level streaming or chunking for large game worlds to manage memory usage
- Optimize asset loading with progressive loading techniques and asset compression
- Use Pixi.js's ticker for smooth animations and game loop management
- Be mindful of the complexity of your scene and optimize draw order
- Use smaller, low-res textures for older mobile devices
- Implement proper bounds management to avoid unnecessary calculations

### Mobile Optimization (Ionic Capacitor)
- Implement touch controls and gestures optimized for mobile devices
- Use responsive design techniques to adapt the game UI for various screen sizes and orientations
- Optimize asset quality and size for mobile devices to reduce load times and conserve bandwidth
- Implement efficient power management techniques to preserve battery life on mobile devices
- Utilize Capacitor plugins for accessing native device features when necessary
- Consider using the 'legacy:true' option for older mobile devices

### Testing and Quality Assurance
- Write comprehensive unit tests for game logic and systems
- Implement integration tests for game scenes and major features
- Create automated performance tests to catch regressions
- Use mocks for external services or APIs
- Implement playtesting tools and analytics for gameplay balance and user experience testing
- Set up automated builds and testing in the CI/CD pipeline
- Use global error and alert handlers
- Integrate a crash reporting service for the application

## GENERAL GAME DEVELOPMENT PRINCIPLES

### Key Conventions
1. Follow component-based architecture for modular and reusable game elements
2. Prioritize performance optimization and memory management in every stage of development
3. Maintain a clear and logical project structure to enhance readability and asset management
4. Implement robust testing strategies for game logic, performance, and user experience
5. Consider cross-platform deployment and optimize for various hardware capabilities

### Dependencies and External Libraries
- Carefully evaluate the need for external libraries or plugins
- When choosing external dependencies, consider:
  - Performance impact on game
  - Compatibility with target platforms
  - Active maintenance and community support
  - Documentation quality
  - Ease of integration and future upgrades
- If using native plugins (for sound or device features), handle them in a centralized service

### Advanced Techniques
- Understand and use platform-specific hacks when necessary
- Be aware of performance limitations and implement workarounds when needed
- Utilize advanced features like custom shaders and multi-pass rendering for complex effects
- Implement proper state management systems for game progression and save states
- Use design patterns appropriate for game development (Observer, Command, State patterns)

Refer to platform-specific documentation (Unity, Pixi.js, Lua) and programming guides for best practices in scripting, game architecture, and performance optimization.
