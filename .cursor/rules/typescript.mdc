# TypeScript Development Rules

You are an expert in TypeScript, advanced type system usage, and type-safe programming patterns.

## Core TypeScript Principles

- Write type-safe, scalable TypeScript code with precise type definitions
- Leverage TypeScript's advanced type features for maximum type safety
- Use strict TypeScript configuration settings
- Prefer type inference where appropriate but be explicit when it improves clarity
- Structure code to take advantage of TypeScript's compile-time guarantees

## Advanced Type System Usage

### Type Definitions
- Use `interface` for object shapes that might be extended
- Use `type` for unions, intersections, and computed types
- Prefer `const assertions` for literal types
- Use `satisfies` operator for type checking while preserving literal types
- Implement branded types for domain-specific values

### Generic Programming
- Use generic constraints with `extends` keyword appropriately
- Implement conditional types for complex type logic
- Use mapped types for transforming existing types
- Leverage template literal types for string manipulation
- Implement utility types for common transformations

### Type Guards and Narrowing
- Implement custom type guards with `is` keyword
- Use discriminated unions for type-safe state management
- Leverage `never` type for exhaustive checks
- Use assertion functions for runtime type validation
- Implement proper null/undefined handling

## Configuration and Setup

### tsconfig.json Best Practices
```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  }
}
```

### Strict Type Checking
- Enable all strict mode flags
- Use `noImplicitAny` for catching untyped code
- Enable `strictNullChecks` for null safety
- Use `noImplicitReturns` for complete function coverage
- Enable `exactOptionalPropertyTypes` for precise optional handling

## Error Handling Patterns

### Result Types
```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };
```

### Option Types
```typescript
type Option<T> = T | null | undefined;

function isSome<T>(value: Option<T>): value is T {
  return value != null;
}
```

### Exception Handling
- Use Result types instead of throwing exceptions where appropriate
- Implement proper error boundaries for async operations
- Use union types for expected error conditions
- Leverage exhaustive checking for error handling

## Advanced Patterns

### Builder Pattern with Fluent API
```typescript
class QueryBuilder<T> {
  private constructor(private query: Partial<T>) {}
  
  static create<T>(): QueryBuilder<T> {
    return new QueryBuilder<T>({});
  }
  
  where<K extends keyof T>(key: K, value: T[K]): QueryBuilder<T> {
    return new QueryBuilder({ ...this.query, [key]: value });
  }
  
  build(): Partial<T> {
    return { ...this.query };
  }
}
```

### State Machines with Discriminated Unions
```typescript
type State = 
  | { status: 'loading' }
  | { status: 'success'; data: any }
  | { status: 'error'; error: string };

function handleState(state: State) {
  switch (state.status) {
    case 'loading':
      // TypeScript knows no other properties exist
      break;
    case 'success':
      // TypeScript knows 'data' property exists
      console.log(state.data);
      break;
    case 'error':
      // TypeScript knows 'error' property exists
      console.error(state.error);
      break;
    default:
      // Exhaustive check - TypeScript will error if new states are added
      const _exhaustive: never = state;
  }
}
```

## Performance Optimization

### Type-Only Imports
- Use `import type` for type-only imports
- Leverage `import()` types for conditional type loading
- Use `typeof` operator for inferring types from values
- Implement lazy type evaluation with conditional types

### Compilation Performance
- Use project references for large codebases
- Implement incremental compilation
- Use `skipLibCheck` judiciously
- Optimize with `paths` mapping for module resolution
- Use composite builds for monorepos

## Module System and Declarations

### Module Augmentation
```typescript
declare global {
  namespace Express {
    interface Request {
      user?: User;
    }
  }
}
```

### Ambient Declarations
- Create `.d.ts` files for external libraries
- Use `declare module` for module augmentation
- Implement global type declarations properly
- Use triple-slash directives when necessary

## Testing with TypeScript

### Type-Safe Testing
- Use typed mocks and stubs
- Implement proper type assertions in tests
- Use `as const` for test data
- Leverage conditional types for test utilities

### Test Utilities
```typescript
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

function createMockUser(overrides: DeepPartial<User> = {}): User {
  return {
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    ...overrides
  };
}
```

## API and Schema Validation

### Runtime Validation
- Use libraries like Zod for runtime type validation
- Implement type-safe API clients
- Use schema validation for external data
- Leverage branded types for validated data

### Example with Zod
```typescript
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().min(0).max(150)
});

type User = z.infer<typeof UserSchema>;

function validateUser(data: unknown): User {
  return UserSchema.parse(data);
}
```

## Functional Programming Patterns

### Higher-Order Types
```typescript
type MapFn<T, U> = (value: T) => U;
type FilterFn<T> = (value: T) => boolean;
type ReduceFn<T, U> = (acc: U, value: T) => U;

interface Functor<T> {
  map<U>(fn: MapFn<T, U>): Functor<U>;
}
```

### Immutable Operations
- Use `readonly` modifiers for immutable data
- Implement immutable update patterns
- Use tuple types for fixed-length arrays
- Leverage `const assertions` for immutable literals

## Best Practices Summary

### Code Organization
- Use barrel exports (`index.ts`) for clean imports
- Organize types in dedicated files or sections
- Use namespaces sparingly, prefer modules
- Implement consistent file naming conventions

### Type Safety
- Prefer composition over inheritance
- Use union types over any
- Implement exhaustive checking with `never`
- Use type assertions sparingly and document why

### Documentation
- Use JSDoc comments for complex types
- Document type parameters and constraints
- Explain non-obvious type relationships
- Provide usage examples for complex types

### Tooling Integration
- Configure ESLint with TypeScript rules
- Use Prettier for consistent formatting
- Integrate with IDE for real-time type checking
- Set up pre-commit hooks for type checking

Refer to the TypeScript handbook and advanced type challenges for deeper understanding of complex type system features.
