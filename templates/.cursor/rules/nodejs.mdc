# Node.js Development Rules

You are an expert in Node.js, Express.js, and scalable backend development.

## Core Node.js Principles

- Write performant, scalable Node.js applications using modern JavaScript/TypeScript
- Leverage Node.js's asynchronous, event-driven architecture effectively
- Use npm/yarn package management best practices
- Implement proper error handling and logging
- Structure applications for maintainability and testability

## Express.js Best Practices

### Application Structure
```javascript
// app.js
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');

const app = express();

// Security middleware
app.use(helmet());
app.use(cors());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/users', require('./routes/users'));
app.use('/api/auth', require('./routes/auth'));

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

module.exports = app;
```

### Router Patterns
- Use Express Router for modular route organization
- Implement middleware for authentication and validation
- Use async/await for asynchronous route handlers
- Implement proper error handling in routes
- Use parameter validation and sanitization

### Middleware Best Practices
- Keep middleware functions focused and single-purpose
- Use next() appropriately for control flow
- Implement error-handling middleware with 4 parameters
- Use third-party middleware for common functionality
- Create custom middleware for application-specific logic

## Asynchronous Programming

### Async/Await Patterns
```javascript
// Good: Proper error handling with async/await
async function fetchUserData(userId) {
  try {
    const user = await User.findById(userId);
    const posts = await Post.findByUserId(userId);
    return { user, posts };
  } catch (error) {
    logger.error('Error fetching user data:', error);
    throw new Error('Failed to fetch user data');
  }
}

// Good: Parallel execution when operations are independent
async function fetchDashboardData(userId) {
  try {
    const [user, posts, notifications] = await Promise.all([
      User.findById(userId),
      Post.findByUserId(userId),
      Notification.findByUserId(userId)
    ]);
    return { user, posts, notifications };
  } catch (error) {
    logger.error('Error fetching dashboard data:', error);
    throw error;
  }
}
```

### Event-Driven Architecture
- Use EventEmitter for decoupled component communication
- Implement proper event handling and cleanup
- Use streams for large data processing
- Leverage process events for graceful shutdown
- Implement event-based error handling

### Stream Processing
```javascript
const fs = require('fs');
const { Transform } = require('stream');

const upperCaseTransform = new Transform({
  transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
});

fs.createReadStream('input.txt')
  .pipe(upperCaseTransform)
  .pipe(fs.createWriteStream('output.txt'))
  .on('finish', () => console.log('File processing complete'))
  .on('error', (error) => console.error('Stream error:', error));
```

## Database Integration

### Connection Management
```javascript
// MongoDB with Mongoose
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      maxPoolSize: 10, // Maintain up to 10 socket connections
      serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
    });
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error('Database connection error:', error);
    process.exit(1);
  }
};

// Graceful shutdown
process.on('SIGINT', async () => {
  await mongoose.connection.close();
  console.log('MongoDB connection closed.');
  process.exit(0);
});
```

### Query Optimization
- Use indexes appropriately for frequently queried fields
- Implement pagination for large datasets
- Use aggregation pipelines for complex queries
- Implement proper connection pooling
- Monitor and optimize slow queries

## Security Best Practices

### Input Validation and Sanitization
```javascript
const Joi = require('joi');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss');

// Schema validation
const userSchema = Joi.object({
  name: Joi.string().alphanum().min(3).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])')).required()
});

// Sanitization middleware
app.use(mongoSanitize()); // Remove NoSQL injection attacks
app.use((req, res, next) => {
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = xss(req.body[key]);
      }
    });
  }
  next();
});
```

### Authentication and Authorization
- Use bcrypt for password hashing
- Implement JWT tokens with proper expiration
- Use HTTPS in production
- Implement role-based access control
- Use secure session management

### Environment and Configuration
```javascript
// config/config.js
require('dotenv').config();

const config = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  mongoUri: process.env.MONGODB_URI,
  jwtSecret: process.env.JWT_SECRET,
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '7d',
  
  // Security
  corsOrigin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 900000,
  rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX) || 100,
};

// Validate required environment variables
const requiredEnvVars = ['MONGODB_URI', 'JWT_SECRET'];
requiredEnvVars.forEach(envVar => {
  if (!process.env[envVar]) {
    console.error(`Error: ${envVar} environment variable is not set`);
    process.exit(1);
  }
});

module.exports = config;
```

## Performance Optimization

### Caching Strategies
```javascript
const redis = require('redis');
const client = redis.createClient();

// Simple caching middleware
const cache = (duration = 300) => {
  return async (req, res, next) => {
    const key = `cache:${req.originalUrl}`;
    
    try {
      const cached = await client.get(key);
      if (cached) {
        return res.json(JSON.parse(cached));
      }
      
      res.sendResponse = res.json;
      res.json = (body) => {
        client.setex(key, duration, JSON.stringify(body));
        res.sendResponse(body);
      };
      
      next();
    } catch (error) {
      console.error('Cache error:', error);
      next();
    }
  };
};

// Usage
app.get('/api/users', cache(600), getUsersController);
```

### Memory Management
- Monitor memory usage with process.memoryUsage()
- Implement memory leak detection in development
- Use streams for large file processing
- Implement garbage collection monitoring
- Optimize object creation and cleanup

### Clustering and Scaling
```javascript
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork(); // Restart worker
  });
} else {
  // Workers can share any TCP port
  require('./app.js');
  console.log(`Worker ${process.pid} started`);
}
```

## Error Handling and Logging

### Centralized Error Handling
```javascript
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

// Global error handler
const globalErrorHandler = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';
  
  if (process.env.NODE_ENV === 'development') {
    res.status(err.statusCode).json({
      status: err.status,
      error: err,
      message: err.message,
      stack: err.stack
    });
  } else {
    // Production error response
    if (err.isOperational) {
      res.status(err.statusCode).json({
        status: err.status,
        message: err.message
      });
    } else {
      // Log error
      console.error('ERROR:', err);
      res.status(500).json({
        status: 'error',
        message: 'Something went wrong!'
      });
    }
  }
};
```

### Structured Logging
```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;
```

## Testing Strategies

### Unit Testing
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('User API', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });
  
  describe('POST /api/users', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'Password123!'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      expect(response.body.user.email).toBe(userData.email);
      expect(response.body.user.password).toBeUndefined();
    });
    
    it('should return 400 for invalid email', async () => {
      const userData = {
        name: 'Test User',
        email: 'invalid-email',
        password: 'Password123!'
      };
      
      await request(app)
        .post('/api/users')
        .send(userData)
        .expect(400);
    });
  });
});
```

### Integration Testing
- Test API endpoints with real database connections
- Use test databases for isolation
- Implement setup and teardown procedures
- Test authentication and authorization flows
- Validate error responses and edge cases

## Deployment and Production

### Process Management
```javascript
// Graceful shutdown
const gracefulShutdown = () => {
  console.log('Starting graceful shutdown...');
  
  server.close(() => {
    console.log('HTTP server closed.');
    
    // Close database connections
    mongoose.connection.close(false, () => {
      console.log('MongoDB connection closed.');
      process.exit(0);
    });
  });
  
  // Force close after 10 seconds
  setTimeout(() => {
    console.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
};

process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);
```

### Health Checks and Monitoring
```javascript
// Health check endpoint
app.get('/health', async (req, res) => {
  const health = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV
  };
  
  try {
    // Check database connection
    await mongoose.connection.db.admin().ping();
    health.database = 'connected';
  } catch (error) {
    health.database = 'disconnected';
    health.status = 'ERROR';
  }
  
  const httpStatus = health.status === 'OK' ? 200 : 503;
  res.status(httpStatus).json(health);
});
```

## Package Management

### Dependencies
- Use exact versions for critical dependencies
- Regularly audit dependencies for vulnerabilities
- Use npm ci in production for faster, reliable installs
- Implement dependency updates with automated testing
- Use peer dependencies appropriately

### Performance Monitoring
- Implement APM (Application Performance Monitoring)
- Monitor memory leaks and CPU usage
- Track response times and error rates
- Use profiling tools for performance optimization
- Implement custom metrics for business logic

Follow Node.js best practices documentation and security guidelines for production deployments.
