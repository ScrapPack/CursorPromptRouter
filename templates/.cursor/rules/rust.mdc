# Rust Development Rules

You are an expert in Rust, systems programming, and memory-safe application development.

## Core Rust Principles

- Write safe, efficient, and concurrent Rust code
- Leverage Rust's ownership system for memory safety
- Use Rust's type system to prevent bugs at compile time
- Follow Rust idioms and best practices
- Prefer safe abstractions over unsafe code

## Ownership and Borrowing

### Ownership Rules
- Each value has a single owner
- When the owner goes out of scope, the value is dropped
- Ownership can be moved or borrowed
- Use references instead of taking ownership when possible

```rust
// Good: Borrowing instead of taking ownership
fn calculate_length(s: &String) -> usize {
    s.len()
}

// Usage
let s1 = String::from("hello");
let len = calculate_length(&s1);
println!("Length of '{}' is {}", s1, len);

// Good: Returning ownership
fn take_and_give_back(s: String) -> String {
    s // Return ownership
}
```

### Mutable vs Immutable References
```rust
// Good: Clear borrowing patterns
fn main() {
    let mut s = String::from("hello");
    
    {
        let r1 = &s; // Immutable reference
        let r2 = &s; // Multiple immutable references OK
        println!("{} and {}", r1, r2);
    } // r1 and r2 go out of scope
    
    let r3 = &mut s; // Mutable reference after immutable ones
    r3.push_str(", world");
}
```

## Error Handling

### Result and Option Types
```rust
use std::fs::File;
use std::io::ErrorKind;

// Good: Explicit error handling
fn read_file(filename: &str) -> Result<String, std::io::Error> {
    match File::open(filename) {
        Ok(mut file) => {
            let mut contents = String::new();
            file.read_to_string(&mut contents)?;
            Ok(contents)
        }
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                println!("File not found: {}", filename);
                Err(error)
            }
            other_error => {
                println!("Problem opening file: {:?}", other_error);
                Err(error)
            }
        }
    }
}

// Good: Using ? operator for error propagation
fn read_file_concise(filename: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

### Custom Error Types
```rust
use std::fmt;

#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Parse(std::num::ParseIntError),
    Custom(String),
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MyError::Io(err) => write!(f, "IO error: {}", err),
            MyError::Parse(err) => write!(f, "Parse error: {}", err),
            MyError::Custom(msg) => write!(f, "Custom error: {}", msg),
        }
    }
}

impl std::error::Error for MyError {}

impl From<std::io::Error> for MyError {
    fn from(error: std::io::Error) -> Self {
        MyError::Io(error)
    }
}
```

## Pattern Matching

### Comprehensive Matching
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// Good: Exhaustive pattern matching
fn process_message(msg: Message) {
    match msg {
        Message::Quit => {
            println!("Quit message received");
        }
        Message::Move { x, y } => {
            println!("Move to coordinates: ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("Text message: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change color to RGB({}, {}, {})", r, g, b);
        }
    }
}

// Good: Using if let for single pattern
fn process_write_message(msg: Message) {
    if let Message::Write(text) = msg {
        println!("Writing: {}", text);
    }
}
```

## Traits and Generics

### Trait Definitions
```rust
trait Summary {
    fn summarize(&self) -> String;
    
    // Default implementation
    fn summarize_author(&self) -> String {
        format!("(Read more from {}...)", self.summarize())
    }
}

// Trait implementation
struct Article {
    headline: String,
    location: String,
    author: String,
    content: String,
}

impl Summary for Article {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

// Generic functions with trait bounds
fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}

// Multiple trait bounds
fn notify_and_display<T: Summary + fmt::Display>(item: &T) {
    println!("Breaking news! {}", item.summarize());
    println!("{}", item);
}
```

### Advanced Generics
```rust
// Associated types
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// Where clauses for complex bounds
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // Function body
    0
}
```

## Concurrency

### Threads and Message Passing
```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

// Good: Message passing between threads
fn main() {
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        
        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
    
    for received in rx {
        println!("Got: {}", received);
    }
}
```

### Shared State with Mutex
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Result: {}", *counter.lock().unwrap());
}
```

## Memory Management

### Smart Pointers
```rust
use std::rc::Rc;
use std::cell::RefCell;

// Reference counting for shared ownership
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

// Interior mutability with RefCell
#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

impl Node {
    fn new(value: i32) -> Rc<Node> {
        Rc::new(Node {
            value,
            children: RefCell::new(vec![]),
        })
    }
    
    fn add_child(&self, child: Rc<Node>) {
        self.children.borrow_mut().push(child);
    }
}
```

### Lifetime Annotations
```rust
// Lifetime parameters
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// Struct with lifetime parameters
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
    
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

## Performance Optimization

### Zero-Cost Abstractions
```rust
// Iterators are zero-cost abstractions
let v: Vec<i32> = vec![1, 2, 3, 4, 5];

// This compiles to the same code as a manual loop
let sum: i32 = v.iter().map(|x| x * x).filter(|x| **x > 10).sum();

// Avoiding allocations with iterator adaptors
let filtered: Vec<i32> = v.into_iter()
    .filter(|&x| x > 2)
    .collect();
```

### Efficient String Handling
```rust
// Use String::with_capacity for known sizes
let mut s = String::with_capacity(100);

// Use &str for string slices when possible
fn process_text(text: &str) -> usize {
    text.len()
}

// Efficient string building
let parts = vec!["hello", " ", "world"];
let result = parts.join(""); // More efficient than repeated push_str
```

## Testing

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
    
    #[test]
    fn test_addition() {
        assert_eq!(add(2, 3), 5);
    }
    
    #[test]
    #[should_panic(expected = "divide by zero")]
    fn test_panic() {
        divide(10, 0);
    }
    
    #[test]
    fn test_result() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("divide by zero");
    }
    a / b
}
```

### Integration Tests
```rust
// tests/integration_test.rs
use my_crate;

#[test]
fn it_adds_two() {
    assert_eq!(4, my_crate::add_two(2));
}
```

## Cargo and Project Structure

### Cargo.toml Configuration
```toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <email@example.com>"]
license = "MIT"
description = "A brief description"
repository = "https://github.com/username/my_project"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
clap = "4.0"

[dev-dependencies]
criterion = "0.4"

[[bin]]
name = "main"
path = "src/main.rs"

[lib]
name = "my_project"
path = "src/lib.rs"
```

### Project Organization
```
src/
├── main.rs          # Binary entry point
├── lib.rs           # Library root
├── models/
│   ├── mod.rs
│   ├── user.rs
│   └── post.rs
├── handlers/
│   ├── mod.rs
│   └── api.rs
└── utils/
    ├── mod.rs
    └── helpers.rs
```

## Unsafe Code Guidelines

### When to Use Unsafe
- Interfacing with C code (FFI)
- Implementing low-level data structures
- Performance-critical code with proven safety

```rust
// Safe wrapper around unsafe code
pub struct Vec<T> {
    ptr: *mut T,
    cap: usize,
    len: usize,
}

impl<T> Vec<T> {
    pub fn new() -> Self {
        Vec {
            ptr: std::ptr::NonNull::dangling().as_ptr(),
            cap: 0,
            len: 0,
        }
    }
    
    pub fn push(&mut self, elem: T) {
        if self.len == self.cap {
            self.grow();
        }
        
        unsafe {
            std::ptr::write(self.ptr.add(self.len), elem);
        }
        
        self.len += 1;
    }
    
    fn grow(&mut self) {
        let new_cap = if self.cap == 0 { 1 } else { 2 * self.cap };
        let new_layout = std::alloc::Layout::array::<T>(new_cap).unwrap();
        
        let new_ptr = if self.cap == 0 {
            unsafe { std::alloc::alloc(new_layout) }
        } else {
            let old_layout = std::alloc::Layout::array::<T>(self.cap).unwrap();
            unsafe {
                std::alloc::realloc(
                    self.ptr as *mut u8,
                    old_layout,
                    new_layout.size(),
                )
            }
        };
        
        if new_ptr.is_null() {
            std::alloc::handle_alloc_error(new_layout);
        }
        
        self.ptr = new_ptr as *mut T;
        self.cap = new_cap;
    }
}
```

## Best Practices Summary

### Code Style
- Use `rustfmt` for consistent formatting
- Follow Rust naming conventions (snake_case, PascalCase)
- Write descriptive variable and function names
- Use meaningful commit messages
- Document public APIs with doc comments

### Error Handling
- Use `Result<T, E>` for recoverable errors
- Use `Option<T>` for optional values
- Avoid `unwrap()` and `expect()` in production code
- Create custom error types for domain-specific errors

### Performance
- Profile before optimizing
- Use iterators instead of manual loops
- Prefer `&str` over `String` for string slices
- Use `Vec::with_capacity` when size is known
- Consider `Box`, `Rc`, and `Arc` for different ownership patterns

Follow Rust's ownership principles and leverage the type system for safe, concurrent programming.
